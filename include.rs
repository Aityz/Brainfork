//! This file was generated by Brainfork.
//! Please consider leaving a star at https://github.com/Aityz/Brainfork
#![allow(dead_code)]

/// On Unix we enter raw mode. Windows support will be added later

#[cfg(unix)]
#[repr(C)]
pub struct Termios {
    pub c_iflag: i32,
    pub c_oflag: i32,
    pub c_cflag: i32,
    pub c_lflag: i32,
}

static ECHO: i32 = 0o0000010;
static ICANON: i32 = 0x00002;
static TCSAFLUSH: i32 = 2;

#[cfg(unix)]
extern "C" {
    fn tcgetattr(fd: i32, termios: &mut Termios);
    fn tcsetattr(fd: i32, int: i32, termios: &mut Termios);
    fn read(fd: i32, char: &mut u8, amount: i32);
}

#[cfg(target_os = "linux")]
fn init() {
    let fd = std::os::fd::AsRawFd::as_raw_fd(&std::io::stdout()); // most likely 0

    unsafe {
        let mut termios: Termios = std::mem::zeroed();

        tcgetattr(fd, &mut termios);

        termios.c_lflag &= !(ECHO | ICANON); // disables ECHO and cooked mode

        tcsetattr(fd, TCSAFLUSH, &mut termios);
    }
}

#[cfg(not(target_os = "linux"))]
fn init() {
    // add windows and macos support later
}

#[cfg(target_os = "linux")]
fn close() {
    let fd = std::os::fd::AsRawFd::as_raw_fd(&std::io::stdout());

    unsafe {
        let mut termios: Termios = std::mem::zeroed();

        tcgetattr(fd, &mut termios);

        termios.c_lflag |= ECHO | ICANON; // re-enables echo

        tcsetattr(fd, TCSAFLUSH, &mut termios);
    }
}

#[cfg(not(target_os = "linux"))]
fn close() {
    // add windows support later
}


#[inline(always)]
fn inc_one(ptr: &mut u16, _stack: &Vec<u8>) {
    if *ptr == 29999 {
        *ptr = 0;
    } else {
        *ptr += 1;
    }
}

#[inline(always)]
fn dec_one(ptr: &mut u16, _stack: &Vec<u8>) {
    if *ptr == 0 {
        *ptr = 29999;
    } else {
        *ptr -= 1;
    }
}

#[inline(always)]
fn inc_val(ptr: &mut u16, stack: &mut Vec<u8>) {
    if stack[*ptr as usize] == 255 {
        stack[*ptr as usize] = 0;
    } else {
        stack[*ptr as usize] += 1;
    }
}

#[inline(always)]
fn dec_val(ptr: &mut u16, stack: &mut Vec<u8>) {
    if stack[*ptr as usize] == 0 {
        stack[*ptr as usize] = 255;
    } else {
        stack[*ptr as usize] -= 1;
    }
}

#[inline(always)]
fn print_val(ptr: &mut u16, stack: &Vec<u8>) {
    print!("{}", char::from(stack[*ptr as usize]));
    std::io::Write::flush(&mut std::io::stdout()).unwrap_or_else(|_| {
        println!("Failed to flush Stdout!");
        std::process::exit(1);
    });
}

#[inline(always)]
fn read_val(ptr: &mut u16, stack: &mut Vec<u8>) {
    let mut buf = [0];
    std::io::Read::read_exact(&mut std::io::stdin(), &mut buf).unwrap_or_else(|_| {
        println!("Failed to read from Stdin!");
        std::process::exit(1);
    });

    stack[*ptr as usize] = buf[0];
}

fn main() {
    init();
    let mut stack: Vec<u8> = vec![0; 30000];
    let mut ptr: u16 = 0;
